#include <bits/stdc++.h>
#include "move.h"
#pragma once

using namespace std;

const int doubledPawnsPenalty = 30;

const int mat[] = {0, 100, 320, 330, 500, 900, 20000};

const int passedBonus[] = {0, 7, 16, 17, 64, 170, 270}; /// bonus for a passed pawn on a rank

const int mobilityBonus[6][30] = { /// based on many possible moves a piece has
    {},
    {}, ///Pawn
    {-62, -53, -12, -3, 3, 12, 21, 28, 37}, ///Knight
    {-47, -20, 14, 29, 39, 53, 53, 60, 62, 69, 78, 93, 91, 96}, ///Bishop
    {-60, -24, 0, 3, 4, 14, 20, 30, 41, 41, 41, 45, 57, 58, 67}, ///Rook
    {-29, -16, -8, -8, 18, 25, 23, 37, 41, 54, 65, 68, 69, 70, 70, 70, 71, 72, 74, 76, 90, 104, 105, 106, 112, 114, 114, 119} ///Queen
};

const int knightScoreTable[64] = {
  0	,	-10	,	0	,	0	,	0	,	0	,	-10	,	0	,
  0	,	0	,	0	,	5	,	5	,	0	,	0	,	0	,
  0	,	0	,	10	,	10	,	10	,	10	,	0	,	0	,
  0	,	0	,	10	,	20	,	20	,	10	,	5	,	0	,
  5	,	10	,	15	,	20	,	20	,	15	,	10	,	5	,
  5	,	10	,	10	,	20	,	20	,	10	,	10	,	5	,
  0	,	0	,	5	,	10	,	10	,	5	,	0	,	0	,
  0	,	0	,	0	,	0	,	0	,	0	,	0	,	0
};

const int bishopScoreTable[64] = {
  0	,	0	,	-10	,	0	,	0	,	-10	,	0	,	0	,
  0	,	0	,	0	,	10	,	10	,	0	,	0	,	0	,
  0	,	0	,	10	,	15	,	15	,	10	,	0	,	0	,
  0	,	10	,	15	,	20	,	20	,	15	,	10	,	0	,
  0	,	15	,	15	,	20	,	20	,	15	,	15	,	0	,
  0	,	0	,	10	,	15	,	15	,	10	,	0	,	0	,
  0	,	0	,	0	,	10	,	10	,	0	,	0	,	0	,
  0	,	0	,	0	,	0	,	0	,	0	,	0	,	0
};

const int rookScoreTable[64] = {
  0	,	0	,	5	,	10	,	10	,	5	,	0	,	0	,
  0	,	0	,	5	,	10	,	10	,	5	,	0	,	0	,
  0	,	0	,	5	,	10	,	10	,	5	,	0	,	0	,
  0	,	0	,	5	,	10	,	10	,	5	,	0	,	0	,
  0	,	0	,	5	,	10	,	10	,	5	,	0	,	0	,
  0	,	0	,	5	,	10	,	10	,	5	,	0	,	0	,
  25,	25	,	25	,	25	,	25	,	25	,	25	,	25	,
  0	,	0	,	5	,	10	,	10	,	5	,	0	,	0
};

const int kingEndgame[64] = {
	-50	,	-10	,	0	,	0	,	0	,	0	,	-10	,	-50	,
	-10,	0	,	10	,	10	,	10	,	10	,	0	,	-10	,
	0	,	10	,	20	,	20	,	20	,	20	,	10	,	0	,
	0	,	10	,	20	,	40	,	40	,	20	,	10	,	0	,
	0	,	10	,	20	,	40	,	40	,	20	,	10	,	0	,
	0	,	10	,	20	,	20	,	20	,	20	,	10	,	0	,
	-10,	0	,	10	,	10	,	10	,	10	,	0	,	-10	,
	-50	,	-10	,	0	,	0	,	0	,	0	,	-10	,	-50
};

const int kingMiddlegame[64] = {
	0	,	5	,	5	,	-10	,	-10	,	0	,	10	,	5	,
	-30	,	-30	,	-30	,	-30	,	-30	,	-30	,	-30	,	-30	,
	-50	,	-50	,	-50	,	-50	,	-50	,	-50	,	-50	,	-50	,
	-70	,	-70	,	-70	,	-70	,	-70	,	-70	,	-70	,	-70	,
	-70	,	-70	,	-70	,	-70	,	-70	,	-70	,	-70	,	-70	,
	-70	,	-70	,	-70	,	-70	,	-70	,	-70	,	-70	,	-70	,
	-70	,	-70	,	-70	,	-70	,	-70	,	-70	,	-70	,	-70	,
	-70	,	-70	,	-70	,	-70	,	-70	,	-70	,	-70	,	-70
};

int count(uint64_t bb) {
  return __builtin_popcountll(bb);
}

int matEval(Board *board, int color) {
  uint64_t pieces = board->pieces[color];
  int matScore = 0;
  while(pieces) {
    uint64_t b = lsb(pieces);
    int sq = Sq(b);
    matScore += mat[board->piece_type_at(sq)];
    pieces ^= b;
  }
  return matScore;
}

int activeEval(Board *board, int color, bool isEndgame) {
  uint64_t pieces = 0;
  int activeScore = 0;
  if(color == WHITE) {
    pieces = board->bb[WN] | board->bb[WB] |
             board->bb[WR] | board->bb[WK];
  } else {
    pieces = board->bb[BN] | board->bb[BB] |
             board->bb[BR] | board->bb[BK];
  }
  while(pieces) {
    uint64_t b = lsb(pieces);
    int sq = Sq(b), pieceType = board->piece_type_at(sq), sq2 = (color == WHITE ? sq : (7 - sq / 8) * 8 + sq % 8);
    switch(pieceType) {
      case KNIGHT:
        activeScore += knightScoreTable[sq2];
        break;
      case BISHOP:
        activeScore += bishopScoreTable[sq2];
        break;
      case ROOK:
        activeScore += rookScoreTable[sq2];
        break;
      case KING:
        if(isEndgame)
          activeScore += kingEndgame[sq2];
        else
          activeScore += kingMiddlegame[sq2];
        break;
      default:
        break;
    }
    pieces ^= b;
  }
  return activeScore;
}

int centerEval(Board *board, int color) {
  int centerScore = 0;
  uint64_t pieces = board->pieces[color] & CENTER;
  while(pieces) {
    uint64_t b = lsb(pieces);
    int sq = Sq(b), pieceType = board->piece_type_at(sq);
    if(pieceType == PAWN)
      centerScore += 30;
    else
      centerScore += 20;
    pieces ^= b;
  }
  return centerScore;
}

int rookEval(Board *board, int color) {
  int rookScore = 0;
  uint64_t pieces = 0;
  if(color == WHITE) {
    pieces = board->bb[WR];
  } else {
    pieces = board->bb[BR];
  }
  while(pieces) {
    uint64_t b = lsb(pieces);
    int sq = Sq(b);
    /// check if open file
    if(!((board->bb[WP] | board->bb[BP]) & fileMask[sq & 7]))
      rookScore += 30;
    else if(!(board->bb[color] & fileMask[sq & 7])) /// semi open file
      rookScore += 20;
    pieces ^= b;
  }
  return rookScore;
}

int pawnEval(Board *board, int color) {
  int pawnScore = 0;
  uint64_t pawns;
  if(color == WHITE)
    pawns = board->bb[WP];
  else
    pawns = board->bb[BP];
  while(pawns) {
    uint64_t b = lsb(pawns);
    int sq = Sq(b), rank = sq >> 3;
    /// check for passed pawn
    if(color == WHITE) {
      if(!(neighFileUpMask[sq] & board->bb[BP])) {
        if(!(fileUpMask[sq] & board->bb[WP])) /// in case of double pawns, the one in the front is passed, but the other is not
          pawnScore += passedBonus[rank];
      }
      if(fileUpMask[sq] & board->bb[WP])
        pawnScore -= doubledPawnsPenalty;
    } else {
      if(!(neighFileDownMask[sq] & board->bb[WP])) {
        if(!(fileDownMask[sq] & board->bb[BP])) /// in case of double pawns, the one in the front is passed, but the other is not
          pawnScore += passedBonus[7 - rank];
      }
      if(fileDownMask[sq] & board->bb[BP])
        pawnScore -= doubledPawnsPenalty;
    }
    pawns ^= b;
  }
  return pawnScore;
}

int mobilityEval(Board *board, int color) {
  uint64_t pieces = 0;
  int mobilityScore = 0;
  if(color == WHITE) {
    pieces = board->bb[WN] | board->bb[WB] |
             board->bb[WR] | board->bb[WQ];
  } else {
    pieces = board->bb[BN] | board->bb[BB] |
             board->bb[BR] | board->bb[BQ];
  }
  while(pieces) {
    uint64_t b = lsb(pieces);
    int sq = Sq(b), pieceType = board->piece_type_at(sq);
    mobilityScore += mobilityBonus[pieceType][count(genAttacksSq(board->allPieces, sq, pieceType, 0))];
    pieces ^= b;
  }
  return mobilityScore;
}

int eval(Board *board, int color) {
  int score = 0;
  score += matEval(board, color);
  bool isEndgame = (score - 20000 < 2500);

  //score += activeEval(board, color, isEndgame);
  score += mobilityEval(board, color);
  score += centerEval(board, color);
  score += rookEval(board, color);
  score += pawnEval(board, color);
  return score;
}

int evaluate(Board *board) {
  return eval(board, WHITE) - eval(board, BLACK);
}
